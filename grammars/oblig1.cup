package oblig1parser;
import java_cup.runtime.*;
import syntaxtree.*;
import java.util.*;

parser code {:

:};

/* Terminals */
terminal                        CLASS;
terminal                        LBRACK, RBRACK;
terminal                        LPAR, RPAR;
terminal                        SEMI, RETURN;
terminal                        PROCEDURE;

/********************/
terminal                        VAR;
terminal                        INT;
terminal						COMMA;
terminal						PROC;
/*******************/
terminal String                 ID;
terminal String                 STRING_LITERAL;

/* Non terminals */
non terminal Program            program;
non terminal List<Decl>         decl_list, decl_list_bdy;
non terminal Decl          class_decl, decl;

/*****************/
non terminal VarDecl            var_decl;
non terminal List<VarDecl>      var_decl_list, var_decl_list_bdy;
non terminal List<ParamDecl>    param_decl_list, param_decl_list_bdy;	
non terminal ParamDecl   	    param_decl;
non terminal ProcDecl			proc_decl;
non terminal List<Stmt>			stmt_list;
non terminal Stmt				stmt;
non terminal CallStmt			call_stmt;
non terminal Type               type;
/*****************/


/* The grammar */
program                 ::= decl_list:dl
                        {: RESULT = new Program(dl); :} 
                        ;
						
decl_list				::= /* EMPTY */
						{: RESULT = new LinkedList<Decl>(); :}
						| decl_list_bdy:dl
						{: RESULT = dl; :}
						;
						
decl_list_bdy           ::= decl:d {: List<Decl> l = new LinkedList<Decl>();
                                      l.add(d);
                                      RESULT = l; :} 
                        |   decl_list_bdy:dl decl:d 
                            {: dl.add(d); RESULT = dl; :}
                        ;

decl                    ::= class_decl:sd 
						{: RESULT = sd; :}
                        |   var_decl:vd 
						{: RESULT = vd; :}
						| proc_decl:pd 
                        {: RESULT = pd; :}
						;
                                  
class_decl              ::= CLASS ID:name LBRACK var_decl_list:vdl RBRACK
                        {: RESULT = new ClassDecl(name,vdl); :}
                        ;

/* 
 * var_decl_list -> [var_decl_list_bdy] 
 * var_decl_list -> EMPTY | var_decl_list_bdy
 */
var_decl_list		    ::= /* EMPTY */
						{: RESULT = new LinkedList<VarDecl>(); :}
						|	var_decl_list_bdy:vdl {: RESULT = vdl; :}	
						;

/*
 * var_decl_list_bdy -> {var_decl}
 * var_decl_list_bdy -> var_decl | var_decl_list_bdy var_decl
 */
var_decl_list_bdy       ::=	var_decl:vd 
						{: List<VarDecl> l = new LinkedList<VarDecl>();
                                         l.add(vd);
                                         RESULT = l; :}
                        | var_decl_list_bdy:vdl var_decl:vd {: vdl.add(vd); RESULT = vdl; :}
						;
						
var_decl                ::= VAR type:typename ID:name SEMI {:  RESULT = new VarDecl(name, typename); :}
                        ;
						
/* 
 * param_decl_list -> [param_decl_list_bdy] 
 * param_decl_list -> EMPTY | param_decl_list_bdy
 */
param_decl_list		    ::= /* EMPTY */
						{: 	RESULT = new LinkedList<ParamDecl>(); :}
						|	param_decl_list_bdy:pdl 
						{: 	RESULT = pdl; :}
						;

/*
 * param_decl_list_bdy -> param_decl {"," PARAM_DECL}
 * param_decl_list_bdy -> param_decl | param_decl_list_bdy "," param_decl 
 */
param_decl_list_bdy     ::=	param_decl:pd 
						{: List<ParamDecl> l = new LinkedList<ParamDecl>();
                                         l.add(pd);
                                         RESULT = l; :}
						| param_decl_list_bdy:pdl COMMA param_decl:pd 
						{: pdl.add(pd); RESULT = pdl; :}
						;
/*
 * param_decl -> ["var"] TYPE NAME
 * param_decl -> TYPE NAME | "var" TYPE NAME
 */ 
param_decl              ::= type:typename ID:name  
						{:  RESULT = new ParamDecl(name, typename, false); :}
						| 	VAR type:typename ID:name
						{:  RESULT = new ParamDecl(name, typename, true); :}
                        ;
						
/*
 * proc_decl -> "proc" [ "ret" TYPE ] NAME "(" [PARAM_DECL {"," PARAM_DECL}] ")" "{" {DECL} {STMT} "}"
 * proc_decl -> "proc" NAME "(" param_decl_list ")" "{" decl_list stmt_list "}"
			  | "proc" "ret" TYPE NAME "(" param_decl_list ")" "{" decl_list stmt_list "}"
 */
 proc_decl				::= PROC ID:name LPAR param_decl_list:pdl RPAR LBRACK decl_list_bdy:dl stmt_list:sl RBRACK
						{: RESULT = new ProcDecl(name,pdl,dl,sl); :}
						;

/*
 * stmt_list -> {STMT}
 * stmt_list -> stmt | stmt_list stmt
 */
 stmt_list				::= stmt:s
						{: List<Stmt> l = new LinkedList<Stmt>();
							l.add(s);
							RESULT = l; :}
						| stmt_list:sl stmt:s
						{:	sl.add(s);
							RESULT = sl;
						:}
						;
						
/*
 * stmt -> assign_stmt ";" | if_stmt | while_stmt | return_stmt ";" | call_stmt ";"
 */
 stmt					::= call_stmt:cs SEMI
						{: RESULT = cs; :}
						;
						
/*
 * call_stmt -> NAME "(" [ ACTUAL_PARAM { "," ACTUAL_PARAM } ] ")"
 * call_stmt -> NAME "(" actual_param_list ")"
 */
 call_stmt				::= ID:name LPAR /* actual_param_list:apl */ RPAR
						{: RESULT = new CallStmt(name); :}
						;
							
 
type                    ::= INT {: RESULT = new Type("int"); :} 
                        ;
